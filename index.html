<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>Tetris — простая реализация</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  /* -------------  Визуальная часть ------------- */
  body{
    font-family: Arial,Helvetica,sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    background:#222;
    color:#fff;
    margin:0;
    padding:0;
    height:100vh;
  }
  h1{margin:20px 0;}
  #game{
    display:flex;
    gap:20px;
    justify-content:center;
    align-items:flex-start;
  }
  /* 2‑дименсиональная сетка из DIV‑ов */
  .grid{
    display:grid;
    grid-template-rows:repeat(20, 25px);
    grid-template-columns:repeat(10, 25px);
    gap:1px;
    background:#111;
    width:max-content;
    padding:1px;
  }
  .cell{
    width:25px;height:25px;
    background:#000;
    border-radius:3px;
  }
  /* Цвета фигур */
  .I{background:#0ff;}
  .J{background:#00f;}
  .L{background:#ffa500;}
  .O{background:#ff0;}
  .S{background:#0f0;}
  .T{background:#800080;}
  .Z{background:#f00;}
  /* Оценка и таймер */
  #info{
    font-size:1.1rem;
  }
</style>
</head>
<body>

<h1>Tetris</h1>
<div id="game">
  <div id="field" class="grid"></div>  <!-- игровое поле -->
  <div id="info">
    <p>Очки: <span id="score">0</span></p>
    <p>Следующий блок:</p>
    <div id="next" class="grid"></div>
  </div>
</div>

<script>
/* -----------------------  Идея -----------------------
   1. Поле – 10×20 ячеек, хранится как 2‑мерный массив.
   2. Фигуры – массивы 4×4, каждый элемент 0/1. 4 ориентации.
   3. Текущее положение (x, y) и тип фигуры.  y растёт вверх → вниз.
   4. Поворот, движение влево/вправо/вниз, авто‑сдвиг каждую секунду.
   5. Сброс линии, обновление счета.
   6. Генерация «следующей» фигуры и простое завершение игры. ----------
*/

const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 25; // px

// Список фигур (4 ориентации, 4x4 матрицы)
const SHAPES = {
  I: [
    [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    [
      [0,0,1,0],
      [0,0,1,0],
      [0,0,1,0],
      [0,0,1,0]
    ],
    [
      [0,0,0,0],
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0]
    ],
    [
      [0,1,0,0],
      [0,1,0,0],
      [0,1,0,0],
      [0,1,0,0]
    ]
  ],
  J: [
    [
      [1,0,0],
      [1,1,1],
      [0,0,0]
    ],
    [
      [0,1,1],
      [0,1,0],
      [0,1,0]
    ],
    [
      [0,0,0],
      [1,1,1],
      [0,0,1]
    ],
    [
      [0,1,0],
      [0,1,0],
      [1,1,0]
    ]
  ],
  L: [
    [
      [0,0,1],
      [1,1,1],
      [0,0,0]
    ],
    [
      [0,1,0],
      [0,1,0],
      [0,1,1]
    ],
    [
      [0,0,0],
      [1,1,1],
      [1,0,0]
    ],
    [
      [1,1,0],
      [0,1,0],
      [0,1,0]
    ]
  ],
  O: [
    [
      [1,1],
      [1,1]
    ],
    // Остальные ориентации идентичны, но оставляем для консистентности
    [
      [1,1],
      [1,1]
    ],
    [
      [1,1],
      [1,1]
    ],
    [
      [1,1],
      [1,1]
    ]
  ],
  S: [
    [
      [0,1,1],
      [1,1,0],
      [0,0,0]
    ],
    [
      [0,1,0],
      [0,1,1],
      [0,0,1]
    ],
    [
      [0,0,0],
      [0,1,1],
      [1,1,0]
    ],
    [
      [1,0,0],
      [1,1,0],
      [0,1,0]
    ]
  ],
  T: [
    [
      [0,1,0],
      [1,1,1],
      [0,0,0]
    ],
    [
      [0,1,0],
      [0,1,1],
      [0,1,0]
    ],
    [
      [0,0,0],
      [1,1,1],
      [0,1,0]
    ],
    [
      [0,1,0],
      [1,1,0],
      [0,1,0]
    ]
  ],
  Z: [
    [
      [1,1,0],
      [0,1,1],
      [0,0,0]
    ],
    [
      [0,0,1],
      [0,1,1],
      [0,1,0]
    ],
    [
      [0,0,0],
      [1,1,0],
      [0,1,1]
    ],
    [
      [0,1,0],
      [1,1,0],
      [1,0,0]
    ]
  ]
};

const COLORS = {
  I: '#00ffff',
  J: '#0000ff',
  L: '#ffa500',
  O: '#ffff00',
  S: '#00ff00',
  T: '#800080',
  Z: '#ff0000'
};

// -------------- Основные классы -----------------

class Piece {
  constructor(type) {
    this.type = type;
    this.rotation = 0;           // 0–3
    this.shape = SHAPES[type];
    this.matrix = this.shape[this.rotation];
    // Начальное положение: центр поля
    this.x = Math.floor((COLS - this.matrix[0].length) / 2);
    this.y = 0;
  }
  rotate() {
    this.rotation = (this.rotation + 1) % 4;
    this.matrix = this.shape[this.rotation];
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

class Tetris {
  constructor() {
    this.grid = this.createEmptyGrid();
    this.score = 0;
    this.gameOver = false;
    this.spawn();
    this.nextPiece = new Piece(this.randomShape());
    this.updateNextGrid();
    this.loop();
  }

  // --- Поля и вспомогательные методы ---
  createEmptyGrid() {
    const rows = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    return rows;
  }

  randomShape() {
    const keys = Object.keys(SHAPES);
    return keys[Math.floor(Math.random() * keys.length)];
  }

  // Проверка коллизии текущего блока с полем или краями
  isColliding(piece, offsetX = 0, offsetY = 0) {
    const m = piece.matrix;
    const oX = piece.x + offsetX;
    const oY = piece.y + offsetY;

    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x]) {  // если в матрице есть блок
          const gx = oX + x;
          const gy = oY + y;
          if (gx < 0 || gx >= COLS || gy >= ROWS) return true; // за пределы
          if (gy >= 0 && this.grid[gy][gx]) return true;      // уже занят
        }
      }
    }
    return false;
  }

  // Очищаем строки и обновляем счёт
  clearLines() {
    let linesCleared = 0;
    for (let y = ROWS - 1; y >= 0; --y) {
      if (this.grid[y].every(cell => cell)) {
        this.grid.splice(y, 1);                     // удаляем строку
        this.grid.unshift(Array(COLS).fill(null));  // вставляем пустую сверху
        ++linesCleared;
        y++; // проверяем строку на новую позицию
      }
    }
    if (linesCleared) {
      this.score += [0, 40, 100, 300, 1200][linesCleared]; // стандартные очки
    }
  }

  // Пересоздаём текущий блок
  spawn() {
    this.current = this.nextPiece;
    this.nextPiece = new Piece(this.randomShape());
    this.current.x = Math.floor((COLS - this.current.matrix[0].length) / 2);
    this.current.y = 0;
    if (this.isColliding(this.current)) {
      this.gameOver = true;
    }
    this.updateNextGrid();
  }

  // Поставить блок в сетку
  lockPiece() {
    const m = this.current.matrix;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x]) {
          const gx = this.current.x + x;
          const gy = this.current.y + y;
          if (gy >= 0) {
            this.grid[gy][gx] = this.current.type;
          }
        }
      }
    }
  }

  // ----- Основной цикл и рендер -----
  loop() {
    if (this.gameOver) {
      this.render();
      document.getElementById('status').innerText = 'Игра окончена!';
      return;
    }

    // Авто‑сдвиг вниз
    if (!this.isColliding(this.current, 0, 1)) {
      this.current.move(0, 1);
    } else {
      this.lockPiece();
      this.clearLines();
      this.spawn();
    }

    this.render();
    setTimeout(() => this.loop(), 500); // 500 мс → 2 блока в секунду
  }

  // Отрисовка всей сцены (поле + текущий блок + след. блок)
  render() {
    this.drawGrid();
    this.drawNext();
    document.getElementById('score').innerText = this.score;
  }

  // Поля: обычный 2‑доменный див
  drawGrid() {
    const field = document.getElementById('field');
    field.innerHTML = '';
    const tempGrid = this.grid.map(row => [...row]); // копия
    // Вставляем текущий блок
    const m = this.current.matrix;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x]) {
          const gx = this.current.x + x;
          const gy = this.current.y + y;
          if (gy >= 0) tempGrid[gy][gx] = this.current.type;
        }
      }
    }
    for (let y = 0; y < ROWS; ++y) {
      for (let x = 0; x < COLS; ++x) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const type = tempGrid[y][x];
        if (type) cell.style.backgroundColor = COLORS[type];
        field.appendChild(cell);
      }
    }
  }

  // Отрисовка «следующего» блока
  drawNext() {
    const nextField = document.getElementById('next');
    nextField.innerHTML = '';
    const m = this.nextPiece.matrix;
    const size = 4; // максимальный размер 4×4
    for (let y = 0; y < size; ++y) {
      for (let x = 0; x < size; ++x) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        if (m[y] && m[y][x]) {
          cell.style.backgroundColor = COLORS[this.nextPiece.type];
        }
        nextField.appendChild(cell);
      }
    }
  }
}

/* ------------------- Обработчики клавиш ------------------- */
const game = new Tetris();
document.addEventListener('keydown', e => {
  if (game.gameOver) return;
  switch (e.key) {
    case 'ArrowLeft':
      if (!game.isColliding(game.current, -1, 0))
        game.current.move(-1, 0);
      break;
    case 'ArrowRight':
      if (!game.isColliding(game.current, 1, 0))
        game.current.move(1, 0);
      break;
    case 'ArrowDown':
      if (!game.isColliding(game.current, 0, 1))
        game.current.move(0, 1);
      break;
    case 'ArrowUp':
      const oldRot = game.current.rotation;
      game.current.rotate();
      if (game.isColliding(game.current)) {   // если коллизия → откат
        game.current.rotation = oldRot;
        game.current.matrix = game.current.shape[oldRot];
      }
      break;
    case ' ':
      // Свернуть
      while (!game.isColliding(game.current, 0, 1)) {
        game.current.move(0, 1);
      }
      break;
  }
});
</script>
</body>
</html>
